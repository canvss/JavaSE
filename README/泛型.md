### 泛型(Generic)

#### 泛型概述

泛型在Java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。

Java泛型是JDK5中引入了一个新特性，泛型提供了编译时类型安全检测机制，该机制允许开发人员在编译时检测到非法的类型。泛型即位类型参数，这个类型参数在声明它的类、接口或方法中，代表未知的某种类型。泛型的本质是参数化类型，也就是所有操作的数据类型被指定为一个参数。

#### 泛型引入

在Java中，我们在声明方法时，当在完成方法功能时如果有未知的数据需要参与，这些未知的数据需要在调用方法时才能确定，那么我们把这样的数据通过行参表示。在方法体中，用这个行参来代表那个未知的数据，而调用者在调用时，对应的传入实参就可以了。

```java
 	//JDK8 ArrayList源码
	public E set(int index, E element) {
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        return oldValue;
    }
```

- 集合类在设计阶段/声明阶段不能确定这个容器具体存了什么类型的对象，所有在JDK5.0之前只能把元素类型设计为Object，在JDK5.0时Java引入了参数化类型(Parameterized type)的概念，允许我们在创建集合时指定集合元素的类型。比如：`List <String>`，表明这个List只能保存字符串类型的对象。

- `java.lang.Comparable`接口和`java.lang.Comparator`接口，是用于比较对象大小的接口。这两个接口只是限定了两个对象的比较返回值，但是并不确定是什么类型的对象比较大小。JDK5.0之前只能用Object类型表示，使用时既麻烦又不安全，因此JDK5.0给它们增加了泛型

```java
//JDK8源码
public interface Comparable<T> {
    public int compareTo(T o);
}
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

> <T>就是泛型参数，即泛型。
>
> 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值或者参数的类型。这个类型参数将在使用时确定。

#### 集合中使用泛型

**集合中没有使用泛型**

<img src="imgs/image-20220411001522636.png" style="zoom:80%;" />

**集合中使用泛型时**

<img src="imgs/image-20220411001549747.png" style="zoom:80%;" />

> Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。即，把不安全的因素在编译期间就排除了，而不是运行期；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。同时代码更加简洁、健壮。把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。

```java
public class CollectionMapGenericTest {
    @Test
    public void test01() {
        ArrayList list = new ArrayList();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add("五");
        int i = (int) list.get(4);  //ClassCastException
        System.out.println(i);
    }
    @Test
    public void test02() {
        ArrayList<Integer> list = new ArrayList<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        //list.add("五"); //编译不通过。
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()) System.out.println(iterator.next());
    }
    @Test
    public void test03(){
        HashMap<Integer,String> map = new HashMap<Integer,String>();
        map.put(1001,"Tom");
        map.put(1002,"Jack");
        map.put(1003,"Jerry");
//        map.put("1004","Canvs");  //编译不通过
//        map.put(1005,'A');    //编译不通过
        Collection<String> coll = map.values();
        for (String s : coll) System.out.println(s);
    }
    @Test
    public void test04(){
        HashMap<Integer,String> map = new HashMap<>();
        map.put(1001,"Tom");
        map.put(1002,"Jack");
        map.put(1003,"Jerry");
        Set<Integer> keySet = map.keySet();
        for (Integer i : keySet) System.out.println(i);
    }
    @Test
    public void test05(){
        HashMap<Integer,String> map = new HashMap<>();
        map.put(1001,"Tom");
        map.put(1002,"Jack");
        map.put(1003,"Jerry");
        //遍历entry集
        Set<Map.Entry<Integer,String>> entrySet = map.entrySet();
        Iterator<Map.Entry<Integer,String>> iterator = entrySet.iterator();
        while (iterator.hasNext()) System.out.println(iterator.next());
    }
}
```

**练习1**:

- 创建创建一个ArrayList集合对象，并指定泛型为\<Integer>
- 添加5个[0,100)以内的整数到集合中
- 使用foreach遍历输出5个整数
- 使用集合的removeIf方法删除偶数，为Predicate接口指定泛型\<Ineteger>
- 再使用Iterator迭代器输出剩下的元素，为Iterator接口指定泛型\<Integer>

```java
public class NumberTest {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        Random random = new Random();
        for (int i = 0; i < 5; i++) {
            list.add(random.nextInt(100));
        }
        for (Integer i : list) System.out.println(i);
//        使用迭代器删除
//        Iterator<Integer> it = list.iterator();
//        while (it.hasNext()){
//            Integer next = it.next();
//            if (next%2==0){
//                it.remove();
//            }
//        }
        list.removeIf(new Predicate<Integer>() {
            @Override
            public boolean test(Integer integer) {
                return integer % 2 == 0;
            }
        });
        System.out.println();
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()) System.out.println(iterator.next());
    }
}
```

#### 比较器中使用泛型

**练习**：

- 定义一个Employee类。该类包含：private成员变量name,age,birthday，其中 birthday 为 MyDate 类的对象；并为每一个属性定义 getter, setter 方法；并重写 toString 方法输出 name, age, birthday

- MyDate类包含:private成员变量year,month,day；并为每一个属性定义 getter, setter 方法；

- 创建该类的 5 个对象，并把这些对象放入 TreeSet 集合中（TreeSet 需使用泛型来定义）

- 分别按以下两种方式对集合中的元素进行排序，并遍历输出：
  - 使Employee 实现 Comparable 接口，并按 name 排序
  - 创建 TreeSet 时传入 Comparator对象，按生日日期的先后排序。

```java
public class Employee implements Comparable<Employee>{
    private String name;
    private int age;
    private MyDate birthday;
    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", birthday=" + birthday +
                '}';
    }
    public Employee(String name, int age, MyDate birthday) {
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    }
    @Override
    public int compareTo(Employee o) {
        return this.name.compareTo(o.name);
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
    public MyDate getBirthday() {
        return birthday;
    }
}
```

```java
public class MyDate implements Comparable<MyDate> {
    private int year;
    private int month;
    private int day;
    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
    @Override
    public String toString() {
        return year + "年" + month + "月" + day + "日";
    }
    @Override
    public int compareTo(MyDate o) {
        int year = this.year - o.year;
        if (year == 0) {
            int month = this.month - o.month;
            if (month == 0) {
                return this.day - o.day;
            }
            return month;
        }
        return year;
    }
}
```

```java
public class EmployeeTest {
    @Test
    public void test01() {
        TreeSet<Employee> set = new TreeSet<Employee>();
        set.add(new Employee("Tom", 22, new MyDate(2000, 7, 25)));
        set.add(new Employee("Jack", 18, new MyDate(1997, 8, 26)));
        set.add(new Employee("Lisa", 19, new MyDate(1998, 5, 5)));
        set.add(new Employee("Jerry", 22, new MyDate(1997, 7, 16)));
        set.add(new Employee("Canvs", 18, new MyDate(2000, 8, 5)));
        Iterator<Employee> iterator = set.iterator();
        while (iterator.hasNext()) System.out.println(iterator.next());
    }
    @Test
    public void test02() {
        //通过年龄排序
        TreeSet<Employee> set = new TreeSet<>(new Comparator<Employee>() {
            @Override
            public int compare(Employee o1, Employee o2) {
                return o1.getBirthday().compareTo(o2.getBirthday());
            }
        });
        set.add(new Employee("Tom", 22, new MyDate(2000, 7, 25)));
        set.add(new Employee("Jack", 18, new MyDate(1997, 8, 26)));
        set.add(new Employee("Lisa", 19, new MyDate(1998, 5, 5)));
        set.add(new Employee("Jerry", 22, new MyDate(1997, 7, 16)));
        set.add(new Employee("Canvs", 18, new MyDate(2000, 8, 5)));
        for (Employee e : set) System.out.println(e);
    }
}
```

#### 相关使用说明

- 在创建集合对象的时候，可以指明泛型的类型
- 集合声明时，声明泛型参数。在使用集合时，可以具体指明泛型的类型。一旦指明，类或接口内部，凡是使用泛型参数的位置，都指定为具体的参数类型。如果没有指明，看作是Object类型。

### 自定义泛型结构

#### 泛型的基础说明

**<类型>这种语法形式就叫泛型**

- <类型>的形式我们称为类型参数，这里的类型习惯上使用T表示，是Type的缩写。即\<T>
- \<T>：代表未知的数据类型，我们可以称为\<String>、\<Interger>、\<Employee>等
  - 类比方法的参数的概念，把\<T>,称为类型形参，将\<Employee>称为类型实参。
- \<T>这里的T可以替换任意字母

**在哪里可以声明类型变量\<T>**

- 声明类或接口时，在类名或接口名后面声明泛型类型，我们把这样的类或接口称为`泛型类`或`接口类`

```java
修饰符】 class 类名<类型变量列表> 【extends 父类】 【implements 接口们】{   
}
【修饰符】 interface 接口名<类型变量列表> 【implements 接口们】{   
}

//例如：
public class ArrayList<E>    
public interface Map<K,V>{
    ....
}    
```

- 声明方法时，在【修饰符】与返回值类型之间声明类型变量，我们把声明了类型变量的方法，称为泛型方法

```java
[修饰符] <类型变量列表> 返回值类型 方法名([形参列表])[throws 异常列表]{
    //...
}
//例如：java.util.Arrays类中的
public static <T> List<T> asList(T... a){
    ....
}
```

#### 自定义泛型类或泛型接口

当我们在类或接口中定义某个成员时，该成员的相关类型是不确定的，而这个类型需要在使用这个类或接口时才可以确定，那么我们可以使用泛型类、泛型接口

**说明**：

- 我们在声明完自定义泛型类以后，可以在类的内部（比如：属性、方法、构造器中）使用类的泛型。
- 我们创建自定义泛型类的对象时，可以指明泛型参数类型。一旦指明，内部凡是使用类的泛型参数的位置，都具体化为指定的类的泛型类型。
- 如果在创建自定义泛型类的对象时，没有指明泛型参数类型，那么泛型将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。
- 泛型的指定中必须是引用数据类型。不能使用基本数据类型，此刻只能使用包装类替换
- 除创建泛型类对象外，子类继承泛型类时、实现类实现泛型接口时，也可以确定泛型结构中的泛型参数。如果我们在给泛型类提供子类时，子类也不确定泛型的类型，则可以继续使用泛型参数。我们还可以在现有的父类的泛型参数基础上，新增泛型参数。

**注意**：

- 泛型类可能有多个参数，此时应将多个参数一起放到尖括号内。如：\<E1,E2,E3>
- 在JDK7.0开始，泛型的简化操作： TreeSet\<Employee> set = new TreeSet\<>();
- 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象
- 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。
- 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，但不可以在静态方法中使用类的泛型。
- 异常类不能是带泛型的。

