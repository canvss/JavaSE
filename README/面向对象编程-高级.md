### 关键字：static

如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（类属性）

- 使用范围
  - 在Java类中，可用static修饰属性、方法、代码块、内部类
- 被修饰后成员特点：
  - 随着类的加载而加载
  - 优先于对象存在
  - 修饰的成员，被所有对象共享
  - 访问权限允许，可以不创建对象，直接被类调用

#### 静态变量

**静态变量特点：**

- 静态变量默认值规则和实例变量一样
- 静态变量值是所有对象共享 
- 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用
  - 如果权限修饰符允许，在其他类中可以通过 `类名.静态变量` 直接访问，也可以通过对象调用
- 静态变量的get/set方法也是静态的，当局部变量与静态变量同名时，使用 `类名.静态变量` 区分

```java
public class Person {
    private String name;
    static String nation;
    public Person(){}
    public Person(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
public class PersonTest {
    public static void main(String[] args) {
        Person.nation = "US";
        System.out.println(Person.nation);
    }
}
```

#### 静态方法

**静态方法特点：**

- 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用
- 只要权限修饰符允许，静态方法在其他类中可以通过 `类名.静态方法` 的方式调用。也可以通过对象调用。
- static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的属性和方法
- 静态方法可以被子类继承，但不能被重写
- 静态方法的调用都只看编译时类型
- 因为不需要实例就可以访问static方法，所以static方法内部不能使用当前类对象this，也不能有super，如果有重名，使用 `类名.` 区别

```java
public class Person {
    private String name;
    private static String nation;
    public static String getNation() {
        return nation;
    }
    public static void setNation(String nation) {
        Person.nation = nation;
    }
    public Person() {}
    public Person(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
public class PersonTest {
    public static void main(String[] args) {
        Person.setNation("America") ;
        System.out.println(Person.getNation()); //America
        Student.setNation("Hongkong");
        System.out.println(Student.getNation());    //Hongkong
    }
}
class Student extends Person{	//static属性可以被继承
}
```

#### 练习

**笔试题：程序执行会不会报错？**

```java
public class StaticInterviewQuestion {
    public static void main(String[] args) {
        Demo d = null;
        d.hello();  
    }
}
class Demo{
    public static void hello(){
        System.out.println("hello!");
    }
}
```

**编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。`账号要自动生成。`**

```java
public class Account {
    private double balance;
    private int id;
    private static double annuallnterestRate;  //年利率
    private static double minBalance;
    private String password;
    private static int idInit=1000;
    public Account(){
        this.id = idInit++;
    }
    public Account(double balance, String password) {
        this();
        this.balance = balance;
        this.password = password;
    }
    public double getBalance() {
        return balance;
    }
    public void setBalance(double balance) {
        this.balance = balance;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public static double getAnnuallnterestRate() {
        return annuallnterestRate;
    }
    public static void setAnnuallnterestRate(double annuallnterestRate) {
        Account.annuallnterestRate = annuallnterestRate;
    }
    public static double getMinBalance() {
        return minBalance;
    }
    public static void setMinBalance(double minBalance) {
        Account.minBalance = minBalance;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getInfo(){
        return "id:"+getId()+" 余额："+getBalance()+" 年利率："+getAnnuallnterestRate()+" 密码："+getPassword();
    }
}
```

```java
public class AccountTest {
    public static void main(String[] args) {
        Account.setAnnuallnterestRate(0.012);
        Account.setMinBalance(10);
        Account ac1 = new Account(2000,"123456");
        Account ac2 = new Account(3000,"123456");
        Account ac3 = new Account(4000,"123456");
        System.out.println(ac1.getInfo()); //id:1000 余额：2000.0 年利率：0.012 密码：123456
        System.out.println(ac2.getInfo()); //id:1001 余额：3000.0 年利率：0.012 密码：123456
        System.out.println(ac3.getInfo()); //id:1002 余额：4000.0 年利率：0.012 密码：123456
    }
}
```

### 单例设计模式（Singleton）

类的单例设计模式，就是采取一定的方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例方法。

**实现思路**

- 将类的构造器访问权限设置为private，这样，就不能用new操作法在类的外部产生类的对象，但在类的内部仍可以产生该类对象
- 类内部创建静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义为静态的

**饿汉式**

```java
public class HungrySingleton {
    private static HungrySingleton singleton = new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance() {
        return singleton;
    }
}
class HungrySingletonTest{
    public static void main(String[] args) {
        HungrySingleton s1 = HungrySingleton.getInstance();
        HungrySingleton s2 = HungrySingleton.getInstance();
        System.out.println(s1 == s2);   //true
    }
}
```

**懒汉式**

```java
public class LazySingleton {
    private static LazySingleton lazySingleton;
    private LazySingleton() {}
    public static LazySingleton getInstance(){
        if(lazySingleton==null){
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
}
class LazySingletonTest{
    public static void main(String[] args) {
        LazySingleton lz1 = LazySingleton.getInstance();
        LazySingleton lz2 = LazySingleton.getInstance();
        System.out.println(lz2 == lz1);
    }
}
```

**饿汉式**

- 特点：立即加载，即在使用类的时候已经将对象创建完毕
- 优点：实现起来简单；没有多线程安全问题
- 缺点：当类被加载时候，会初始化static实例，静态变量被创建分配内存空间，从这以后，这个static的实例一直占着这块内存，知道类被卸载时，静态变量被摧毁，并释放所占有空间。因此在某些特定条件下辉耗费内存

**懒汉式**

- 特点：延迟加载，即在调用静态方法时实例才被创建
- 优点：实现比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存
- 缺点：在多线程环境中，这种实现方法是完全错误的，线程不安全，根本不能保证单例的唯一性

#### 单例模式优点

由于单例模式只生成一个实例，减少了系统性能开销，当一个对象产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式解决。

**应用场景**

- Windows的Task Manager (任务管理器)就是很典型的单例模式

- Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。

- Application 也是单例的典型应用

- 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只

  能有一个实例去操作，否则内容不好追加。

- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。

### 理解main()方法的语法

由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必须创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保持秩序Java命令时传递给运行数组的类的参数

```java
public class CommandPara {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}
```

```shell
canvs@CanvsdeiMac-Pro Desktop % java CommandPara "Tom" "Jack" "Canvs"
```

### 类的成员：代码块

如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，可以考虑代码块（或初始化块）

- 一个类中代码块若有修饰符，则只能是static修饰，称为静态代码块(static block)
- 没有使用static修饰的，为非静态代码块

#### 静态代码块

**静态代码块特点**

- 可以有输出语句
- 可以对类的属性、类的声明进行初始化操作
- 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法
- 若有多个代码块，那么按照从上到下的顺序依次执行
- 静态代码块执行要先于非静态代码块
- 静态代码块随着类的加载而加载，且只执行一次

```java
public class Person {
    private static String name;
    private static int age;
    public Person() {
    }
    static {	//静态方法块
        Person.name = "Canvs";
        Person.age = 20;
    }
    public static String getName() {
        return name;
    }
    public static int getAge() {
        return age;
    }
}
```

```java
public class PersonTest {
    public static void main(String[] args) {
        System.out.println("name="+Person.getName()+" age="+Person.getAge()); 
    }
}
```

#### 非静态代码块

- 和构造器一样，也是用于实例变量的初始化操作
- 如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块，减少冗余

**非静态代码块特点**

- 可以有输出语句
- 可以对类的属性、类的声明进行初始化操作
- 除了调用非静态的结构外，还可以调用静态的变量和方法
- 有多个非静态代码块，那么按照从上到下顺序依次执行
- 每次创建对象的时候，都会执行一次。且先于构造器执行

**例子**

- User类
  - 包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化
  - 包含get/set方法，其中registrationTime没有set方法
  - 包含无参构造
  - 包含有参构造(String username, String password)
  - 包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx”

```java
public class User {
    private String username;
    private String password;
    private long registrationTime;
    public User() {
        this.username = registrationTime+"";
        this.password = "123456";
    }

    {
        this.registrationTime = System.currentTimeMillis();
    }
    public User(String username, String password) {
        this();
        this.username = username;
        this.password = password;
    }
    public String getInfo() {
        return "username:" + username + " password:" + password + " registrationTime:" + registrationTime;
    }
    public String getUsername() {
        return username;
    }
    public void setUsernam(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public long getRegistrationTime() {
        return registrationTime;
    }

}
```

```java
public class UserTest {
    public static void main(String[] args) {
        User u1 = new User();
        User u2 = new User("Canvs", "xjp@fuck");
        System.out.println(u1.getInfo());
        System.out.println(u2.getInfo());
    }
}
```

#### 实例变量赋值顺序

![](imgs/oop_static.jpg)

### final关键字

final：最终的，不可更改的

#### final修饰类

表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。如：String类、System类、StringBuffer类

<img src="imgs/nojjkongfu.jpeg" style='float:left;'  />

```java
final class Eunuch{}
```

#### final修饰方法

表示这个方法不能被子类重写

```java
class Father{
	public final void method(){}
}
```

#### final修饰变量

final修饰某个变量（成员变量或局部变量），一旦赋值，它就不能被修改，即常量，常量命名建议使用大写字母

**修饰成员变量**

```java
public final class FinalTest {
    public static int totalNumber=5;
    public final int ID;
    public FinalTest(){
        ID = ++totalNumber;
    }
    public static void main(String[] args) {
        FinalTest ft = new FinalTest();
        System.out.println(ft.ID);
    }
}
```

**修饰局部变量**

```java
public class FinalTest2 {
    public static void main(String[] args) {
        final int MIN_SCORE;
        MIN_SCORE = 0;
        final int MAX_SCORE=100;
    }
}
```

### 抽象类与抽象方法（abstract）

随着继承层次中一个个新子类定义，类变得越来越具体，而父类则更通用。类的设计应该保证父类和子类能够共享特征。有时将父类设计的非常抽象，以至于它没有具体的实例，这样的类被称为抽象类。

父类声明一个方法但不提供实现，该方法的实现由子类提供，这样的方法称为抽象方法。有一个或更多的抽象方法的类称为抽象类。

#### 语法格式

- 抽象类：被abstract修饰的类
- 抽象方法：被abstract修饰没有方法体的方法

```java
public abstract class Animal {
    public abstract void eat();
}
```

```java
public class Dog extends Animal{
    @Override
    public void eat() {
        System.out.println("狗在吭骨头");
    }
}
```

此时的方法重写，是子类对父类抽象方法的实现，也称实现方法

#### 使用说明

- 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建非抽象子类的对象
  - 假设创建了抽象类的对象，通过对象调用抽象方法，而抽象方法没有具体方法体，没有意义。
  - 抽象类是用类被继承的。
- 抽象类中，也有构造器，是提供子类创建对象时，初始化父类成员变量使用的
  - 子类的构造器中，有默认super()或手动的super(实参列表)，需要访问父类构造器
- 抽象类中，不一定包含抽象方法，但有抽象方法的类必定是抽象类
  - 为包含抽象方法的抽象类，目的就是不让调用者创建该类对象，通常用于某些特殊的类结构设计。
- 抽象类的子类，必须重写抽象父类中的所有抽象方法，否则编译无法通过而报错，除非该子类也是抽象类。
  - 假设不重写抽象类的所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象方法，没有意义。

#### 注意事项

- 不能用abstract修饰变量、代码块、构造器；
- 不能用abstract修饰私有方法、静态方法、final的方法、final的类。

**例子：**

在航运公司系统中，Vehicle类需要定义两个方法分别`计算运输工具的燃料效率`和`行驶距离`。

**问题：**卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。

```java
public abstract class Vehicle {
    public abstract double calcFuelEfficiency();
    public abstract double calcTripDistance();
}
public class Truck extends Vehicle{
    @Override
    public double calcFuelEfficiency() {
        return 0;
    }
    @Override
    public double calcTripDistance() {
        return 0;
    }
}
public class RiverBarge extends Vehicle{
    @Override
    public double calcFuelEfficiency() {
        return 0;
    }
    @Override
    public double calcTripDistance() {
        return 0;
    }
}
```

### 模版方法设计模式(TemplateMethod)

抽象类体现的就是一种模版模式的设计，抽象类作为多个子类的通用模版，子类在抽象类的基础上进行扩展、改造，但子类总体上辉保留类的行为方法。

#### 设计思路

- 当功能内部一部分实现是正确的，另一部分实现是不正确的。这时就可以把不确定的部分暴露出去，让子类去实现。
- 换而言之，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易改，易变的部分可以抽象出来，供不同子类实现。这就是一种模版模式。

**例子：**

```java
public abstract class Template {
    public final void getTime() {
        long start = System.currentTimeMillis();
        code();
        long end = System.currentTimeMillis();
        System.out.println("执行的时间：" + (end - start) + "ms");
    }
    public abstract void code();
}
public class SubTemplate extends Template{
    @Override
    public void code() {
        for (int i = 0; i < 10000; i++) {
            System.out.println(i);
        }
    }
}
public class SubTemplateTest {
    public static void main(String[] args) {
        SubTemplate sub = new SubTemplate();
        sub.code();
        sub.getTime();
    }
}
```

模版方法设计模式是编程中经常用得到的模式。各个框架、类库中都有它的影子，常见的有：

- 数据库访问的封装
- Junit单元测试
- JavaWeb的Servlet中关于doGet/doPost方法调用
- Hibernate中模版程序
- Spring中JDBCTemlate、HibernateTemplate等

#### 练习

工资统计系统设计

```
public abstract class Employee {
    private String name;
    private int number;
    private MyDate birthday;
    public abstract double earnings();
    public String toString(){
        return "姓名:"+getName()+" number:"+getNumber()+" birthday:"+getBirthday().toDateString();
    }
    public Employee() {
    }
    public Employee(String name, int number, MyDate birthday) {
        this.name = name;
        this.number = number;
        this.birthday = birthday;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getNumber() {
        return number;
    }
    public void setNumber(int number) {
        this.number = number;
    }
    public MyDate getBirthday() {
        return birthday;
    }
    public void setBirthday(MyDate birthday) {
        this.birthday = birthday;
    }
}
```

```java
public class HourlyEmployee extends Employee{
    private double wage;
    private double hour;
    public HourlyEmployee() {
    }
    public HourlyEmployee(String name, int number, MyDate birthday, double wage, double hour) {
        super(name, number, birthday);
        this.wage = wage;
        this.hour = hour;
    }
    @Override
    public double earnings() {
        return wage*hour;
    }
    public String toString(){
        return super.toString()+" 工资:"+earnings();
    }
}
```

```java
public class SalariedEmployee extends Employee{
    private double monthlySalary;
    @Override
    public double earnings() {
        return monthlySalary;
    }
    public SalariedEmployee() {
    }
    public SalariedEmployee(String name, int number, MyDate birthday, double monthlySalary) {
        super(name, number, birthday);
        this.monthlySalary = monthlySalary;
    }
    public String toString(){
        return super.toString()+" 工资:"+earnings();
    }
}
```

```java
public class SalariedEmployee extends Employee{
    private double monthlySalary;
    @Override
    public double earnings() {
        return monthlySalary;
    }
    public SalariedEmployee() {
    }
    public SalariedEmployee(String name, int number, MyDate birthday, double monthlySalary) {
        super(name, number, birthday);
        this.monthlySalary = monthlySalary;
    }
    public String toString(){
        return super.toString()+" 工资:"+earnings();
    }
}
```

### 接口(interface)

接口就是规范，定义的是一组规则，体现了世界中“如果你是/要...则必须能...”的思想。继承是一个"是不是"的is-a关系,而接口是“能不能”的has-a关系。

> 引用数据类型：数组，类，枚举，接口，注解

#### 接口声明格式

```java
[修饰符] interface 接口名{}
```

```java
public interface USB {
    void start();
    void stop();
}
```

#### 接口的成员

**JDK8.0之前**

- 公共的静态的常量：其中public static final可以省略
- 公共的抽象的方法：其中public abstract可以省略

**JDK8.0时** ，接口中允许声明默认方法和静态方法：

- 公共的默认方法：其中public可以省略，建议保留，但是default不能省略
- 公共的静态方法：其中public可以省略，建议保留，但是static不能省略

**JDK9.0时**，接口又增加私有方法

> 接口是从多个相似类中抽象出来的规范，不需要提供具体实现；接口中没有构造器，没有初始化块，因为接口中没有成员变量需要初始化

### 接口的使用规则

#### 类实现接口(implements)

接口**不能创建对象**，但是可以被类实现（类似于被继承）

类与接口的关系为实现关系，即**类实现接口**，改类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用implements关键字。

```java
[修饰符] class 实现类 implements 接口{}
```

- 如果接口的实现类是非抽象类，那么必须重写接口中所有抽象方法
- 默认方法可以选择保留，也可以重写。
- 接口中的静态方法不能被继承也不能被重写

> 重写时，default单词就不要再写，他只用于在接口中表示默认方法，在类中就没有默认方法的概念了

```java
public class Computer{
    public static void useFlashDrive(USB usb){
        usb.start();
        System.out.println("USB设备工作中...");
        usb.stop();
    }
}
class ComputerTest{
    public static void main(String[] args) {
        Computer.useFlashDrive(new FlashDrive());
        Computer.useFlashDrive(new Print());
        Computer.useFlashDrive(new USB(){
            @Override
            public void start() {
                System.out.println("移动优盘开始工作");
            }
            public void stop(){
                System.out.println("移动优盘停止工作");
            }
        });
    }
}
```

```java
public interface USB {
    void start();
    void stop();
}
```

```java
public class FlashDrive implements USB{
    @Override
    public void start() {
        System.out.println("U盘开始工作");
    }
    @Override
    public void stop() {
        System.out.println("U盘弹出");
    }
}
```

```java
public class Print implements USB{
    @Override
    public void start() {
        System.out.println("打印机开始工作");
    }
    @Override
    public void stop() {
        System.out.println("打印机停止工作");
    }
}
```

#### 接口的多实现

在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的。这叫做接口的多实现。且一个类能继承一个父类，同时实现多个接口。

```java
[修饰符] class 实现类 implements 接口名,接口名{}
[修饰符] class 实现类 extends 父类 implements 接口名,接口名{}
```

> 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次

**接口**

```java
public  interface Animal {
    void eat();
}
class AnimalTest{
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  //狗吭骨头
        dog.breathe();  //小狗呼吸新鲜空气
    }
}
```

```java
public interface Biological {
    void breathe();
}
```

**接口实现类**

```java
public class Dog  implements Animal,Biological{
    @Override
    public void eat() {
        System.out.println("狗吭骨头");
    }
    @Override
    public void breathe() {
        System.out.println("小狗呼吸新鲜空气");
    }
}
```

#### 接口的多继承(extends)

一个接口能继承另一个或者多个接口，接口的继承也使用extends关键字，子接口继承父接口的方法。

**父接口**

```java
public interface USB3{
    long MAX_SPEED = 500*1024*1024;
    void in();
    void out();
    static void show(){
        System.out.println("USB3.0快速传输");
    }
    default void method(){
        System.out.println("USB3默认方法");
    }
}
```

```java
public interface Chargeable {
    void charge();
    void in();
    void out();
}
```

**子接口**

```java
public interface USBC extends Chargeable,USB3{
    void reverse();
}
```

**子接口实现类**

```java
public class TypeCConverter implements USBC{
    @Override
    public void charge() {
        System.out.println("可充电");
    }
    @Override
    public void in() {
        System.out.println("接收数据");
    }
    @Override
    public void out() {
        System.out.println("输出数据");
    }
    @Override
    public void reverse() {
        System.out.println("正反面都支持");
    }
}
```

> 所有父接口的抽象方法都有重写
>
> 方法签名相同的抽象方法只需要实现一次

#### 接口实现类对象构成多态引用

实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是new的实现类对象的方法体。

```java
public class PeripheralTest {
    public static void main(String[] args) {
      Computer.useUSB(new Mouse());
      Computer.useUSB(new Keyword());
    }
}
class Computer{
    public static void useUSB(USB3 usb){
        usb.in();
        usb.out();
    }
}
class Mouse implements USB3{
    @Override
    public void in() {
        System.out.println("鼠标接收信号");
    }
    @Override
    public void out() {
        System.out.println("鼠标不接收信号");
    }
}
class Keyword implements USB3{
    @Override
    public void in() {
        System.out.println("键盘接收信号");
    }
    @Override
    public void out() {
        System.out.println("键盘不接收信号");
    }
}
```

#### 使用接口的静态成员

接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。

```java
public class USB3Test {
    public static void main(String[] args) {
        USB3.show();    //USB3.0快速传输
        System.out.println(USB3.MAX_SPEED); //524288000
    }
}
```

#### 使用接口的非静态方法

- 对于接口的静态方法，直接使用接口名直接调用；不能通过实现类对象进行调用
- 对于接口的抽象方法、默认方法，只能通过实现类对象调用；接口不能直接创建对象，只能创建实现类的对象

```java
public class MobileHDD implements USB3{
    @Override
    public void in() {}
    @Override
    public void out() { }
}
class MobileHDDTest{
    public static void main(String[] args) {
        MobileHDD hdd = new MobileHDD();
        hdd.method();   //USB3默认方法
    }
}
```

#### 默认方法冲突问题（JDK8）

**类优先原则**

当一个类，既继承一个父类，有实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。

**接口冲突（左右为难）**

- 当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，

#### 接口与抽象类的对比

|     区别     |                  抽象类                  |                 接口                 |
| :----------: | :--------------------------------------: | :----------------------------------: |
|     定义     |           可以包含抽象方法的类           |    主要是抽象方法和全局常量的集合    |
|     组成     | 构造方法、抽象方法、普通方法、常量、变量 |  常量、抽象方法、默认方法、静态方法  |
|     使用     |        子类继承抽象类（extends）         |      子类实现接口（implement）       |
|     关系     |          抽象类可以实现多个接口          | 接口不能继承抽象类，允许继承多个接口 |
| 常见设计模式 |                 模版方法                 |     简单工厂、工厂方法、代理模式     |
|     对象     |     通过对象类的多态性产生实例化对象     |   通过对象类的多态性产生实例化对象   |
|     局限     |           抽象类有单继承局限性           |            接口没有此局限            |
|     实际     |               作为一个模版               |     作为一个标准或是表示一种能力     |

> 如果抽象类和接口都可以使用的条件下，优先使用接口，因为避免单继承的局限性。
>
> 在开发中，常看到一个类不是继承了已经实现好的类，而是要么继承抽象类，要么实现接口。

#### 练习1

- 定义一个接口用来实现两个对象的比较。

- 定义一个Circle类，声明redius属性，提供getter和setter方法

- 定义一个ComparableCircle类，继承Circle类并且实现CompareObject接口。在ComparableCircle类中给出接口中方法compareTo的实现体，用来比较两个圆的半径大小。

- 定义一个测试类InterfaceTest，创建两个ComparableCircle对象，调用compareTo方法比较两个类的半径大小。

**接口类**

```java
public interface CompareObject {
    public int compareTo(Object o);
}
```

**父类**

```java
public class Circle {
    private double redius;
    public Circle() {}
    public Circle(double redius) {
        this.redius = redius;
    }
    public double getRedius() {
        return redius;
    }
    public void setRedius(double redius) {
        this.redius = redius;
    }
}
```

**子类实现类**

```java
public class ComparableCircle extends Circle implements CompareObject{
    public ComparableCircle(double redius) {
        super(redius);
    }
    @Override
    public int compareTo(Object o) {
        if(this == o){
            return 0;
        }
        if(o instanceof ComparableCircle){
            ComparableCircle c = (ComparableCircle) o;
            return Double.compare(c.getRedius(),this.getRedius());
        }
        throw new RuntimeException("输入有误！");
    }
}
```

**测试类**

```java
public class InterfaceTest {
    public static void main(String[] args) {
        CompareObject c1 = new ComparableCircle(2.9);
        CompareObject c2 = new ComparableCircle(2.9);
        System.out.println(c1.compareTo(c2));
    }
}
```

- 思考：参照上述做法定义矩形类Rectangle和ComparableRectangle类，在ComparableRectangle类中给出compareTo方法的实现，比较两个矩形的面积大小。

```java
public interface CompareObject {
    int compareTo(Object o);
}
```

```java
public abstract class Rectangle {
    private double length;
    private double high;
    public Rectangle(double length, double high) {
        this.length = length;
        this.high = high;
    }
    public abstract double findArea();
    public Rectangle() {}
    public double getLength() {
        return length;
    }
    public void setLength(double length) {
        this.length = length;
    }
    public double getHigh() {
        return high;
    }
    public void setHigh(double high) {
        this.high = high;
    }
}
```

```java
public class ComparableRectangle extends Rectangle implements CompareObject {
    public ComparableRectangle() {}
    public ComparableRectangle(double length, double high) {
        super(length, high);
    }
    @Override
    public int compareTo(Object o) {
        if(this == o) {
            return 1;
        }
        if(o instanceof ComparableRectangle){
            ComparableRectangle c = (ComparableRectangle) o;
            if (c.findArea() > this.findArea()){
                return 1;
            }else if(c.findArea() < this.findArea()){
                return -1;
            }else {
                return 0;
            }
        }
        throw new RuntimeException("输入有误！");
    }
    @Override
    public double findArea() {
        return this.getLength() * this.getHigh();
    }
}
```

```java
public class InterfaceTest {
    public static void main(String[] args) {
        CompareObject r1 = new ComparableRectangle(2.3,5);
        CompareObject r2 = new ComparableRectangle(2.3,5);
        System.out.println(r1.compareTo(r2));
    }
}
```

#### 练习2

交通工具案例

<img src="imgs/image-20220504172547709.png" style='float:left;'/>

其中，有一个乘坐交通工具的方法takingVehicle()，在此方法中调用交通工具的run()。为了出行方便，他买了一辆捷安特自行车、一辆雅迪电动车和一辆奔驰轿车。这里涉及到的相关类及接口关系如下：

![image-20220504172918861](/Users/canvs/Desktop/JAVA/01_课件与电子教材/尚硅谷_第08章_面向对象编程（高级）/images/image-20220504172918861.png)

其中，电动车增加动力的方式是充电，轿车增加动力的方式是加油。在具体交通工具的run()中调用其所在类的相关属性信息。

请编写相关代码，并测试。

提示：创建Vehicle[]数组，保存阿里工程师的三辆交通工具，并分别在工程师的takingVehicle()中调用。

```java
public class Developer {
    private String name;
    private int age;
    public Developer(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void takingVehicle(Vehicle vehicle){
        vehicle.run();
    }
    public Developer() {
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
```

```java
public abstract class Vehicle {
    private String brand;
    private String color;
    public abstract void run();
    public String getBrand() {
        return brand;
    }
    public void setBrand(String brand) {
        this.brand = brand;
    }
    public String getColor() {
        return color;
    }
    public void setColor(String color) {
        this.color = color;
    }
    public Vehicle() {
    }
    public Vehicle(String brand, String color) {
        this.brand = brand;
        this.color = color;
    }
}
```

```java
public interface IPower {
    void power();
}
```

```java
public class Bycicle extends Vehicle{
    public Bycicle() { }
    public Bycicle(String brand, String color) {
        super(brand, color);
    }
    @Override
    public void run() {
        System.out.println("行车通过人力脚蹬行驶");
    }
}
```

```java
public class ElectricVehicle extends Vehicle implements IPower{
    public ElectricVehicle(String brand, String color) {
        super(brand, color);
    }
    @Override
    public void run() {
        System.out.println("电动车通过点来行驶");
    }
    public ElectricVehicle() {
    }
    @Override
    public void power() {
        System.out.println("电动车通过电机来增加动力");
    }
}
```

```java
public class Car extends Vehicle implements IPower{
    private String carNumer;
    public String getCarNumer() {
        return carNumer;
    }
    public Car() {}
    public Car(String brand, String color, String carNumer) {
        super(brand, color);
        this.carNumer = carNumer;
    }
    public void setCarNumer(String carNumer) {
        this.carNumer = carNumer;
    }
    @Override
    public void power() {
        System.out.println("汽车通过汽油增加动力");
    }
    @Override
    public void run() {
        System.out.println("汽车通过发动机行驶");
    }
}
```

```java
public class VehicleTest {
    public static void main(String[] args) {
        Developer dev = new Developer("Canvs",22);
        Vehicle[] vehicles = new Vehicle[3];
        vehicles[0] = new Bycicle("捷安特","red");
        vehicles[1] = new ElectricVehicle("雅迪","blue");
        vehicles[2] = new Car("迈巴赫","黑色","沪A8888");
        for (int i = 0; i < vehicles.length; i++) {
            dev.takingVehicle(vehicles[i]);
            if(vehicles[i] instanceof IPower){
                ((IPower) vehicles[i]).power();
            }
        }
    }
}
```

### 内部内(InnerClass)

