### 关键字：static

如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（类属性）

- 使用范围
  - 在Java类中，可用static修饰属性、方法、代码块、内部类
- 被修饰后成员特点：
  - 随着类的加载而加载
  - 优先于对象存在
  - 修饰的成员，被所有对象共享
  - 访问权限允许，可以不创建对象，直接被类调用

#### 静态变量

**静态变量特点：**

- 静态变量默认值规则和实例变量一样
- 静态变量值是所有对象共享 
- 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用
  - 如果权限修饰符允许，在其他类中可以通过 `类名.静态变量` 直接访问，也可以通过对象调用
- 静态变量的get/set方法也是静态的，当局部变量与静态变量同名时，使用 `类名.静态变量` 区分

```java
public class Person {
    private String name;
    static String nation;
    public Person(){}
    public Person(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
public class PersonTest {
    public static void main(String[] args) {
        Person.nation = "US";
        System.out.println(Person.nation);
    }
}
```

#### 静态方法

**静态方法特点：**

- 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用
- 只要权限修饰符允许，静态方法在其他类中可以通过 `类名.静态方法` 的方式调用。也可以通过对象调用。
- static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的属性和方法
- 静态方法可以被子类继承，但不能被重写
- 静态方法的调用都只看编译时类型
- 因为不需要实例就可以访问static方法，所以static方法内部不能使用当前类对象this，也不能有super，如果有重名，使用 `类名.` 区别

```java
public class Person {
    private String name;
    private static String nation;
    public static String getNation() {
        return nation;
    }
    public static void setNation(String nation) {
        Person.nation = nation;
    }
    public Person() {}
    public Person(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
public class PersonTest {
    public static void main(String[] args) {
        Person.setNation("America") ;
        System.out.println(Person.getNation()); //America
        Student.setNation("Hongkong");
        System.out.println(Student.getNation());    //Hongkong
    }
}
class Student extends Person{	//static属性可以被继承
}
```

#### 练习

**笔试题：程序执行会不会报错？**

```java
public class StaticInterviewQuestion {
    public static void main(String[] args) {
        Demo d = null;
        d.hello();  
    }
}
class Demo{
    public static void hello(){
        System.out.println("hello!");
    }
}
```

**编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。`账号要自动生成。`**

```java
public class Account {
    private double balance;
    private int id;
    private static double annuallnterestRate;  //年利率
    private static double minBalance;
    private String password;
    private static int idInit=1000;
    public Account(){
        this.id = idInit++;
    }
    public Account(double balance, String password) {
        this();
        this.balance = balance;
        this.password = password;
    }
    public double getBalance() {
        return balance;
    }
    public void setBalance(double balance) {
        this.balance = balance;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public static double getAnnuallnterestRate() {
        return annuallnterestRate;
    }
    public static void setAnnuallnterestRate(double annuallnterestRate) {
        Account.annuallnterestRate = annuallnterestRate;
    }
    public static double getMinBalance() {
        return minBalance;
    }
    public static void setMinBalance(double minBalance) {
        Account.minBalance = minBalance;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getInfo(){
        return "id:"+getId()+" 余额："+getBalance()+" 年利率："+getAnnuallnterestRate()+" 密码："+getPassword();
    }
}
```

```java
public class AccountTest {
    public static void main(String[] args) {
        Account.setAnnuallnterestRate(0.012);
        Account.setMinBalance(10);
        Account ac1 = new Account(2000,"123456");
        Account ac2 = new Account(3000,"123456");
        Account ac3 = new Account(4000,"123456");
        System.out.println(ac1.getInfo()); //id:1000 余额：2000.0 年利率：0.012 密码：123456
        System.out.println(ac2.getInfo()); //id:1001 余额：3000.0 年利率：0.012 密码：123456
        System.out.println(ac3.getInfo()); //id:1002 余额：4000.0 年利率：0.012 密码：123456
    }
}
```

#### 单例设计模式（Singleton）

类的单例设计模式，就是采取一定的方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例方法。

**饿汉式**

```java
public class HungrySingleton {
    private static HungrySingleton singleton = new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance() {
        return singleton;
    }
}
class HungrySingletonTest{
    public static void main(String[] args) {
        HungrySingleton s1 = HungrySingleton.getInstance();
        HungrySingleton s2 = HungrySingleton.getInstance();
        System.out.println(s1 == s2);   //true
    }
}
```

**懒汉式**

```java
public class LazySingleton {
    private static LazySingleton lazySingleton;
    private LazySingleton() {}
    public static LazySingleton getInstance(){
        if(lazySingleton==null){
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
}
class LazySingletonTest{
    public static void main(String[] args) {
        LazySingleton lz1 = LazySingleton.getInstance();
        LazySingleton lz2 = LazySingleton.getInstance();
        System.out.println(lz2 == lz1);
    }
}
```

**饿汉式**

- 特点：立即加载，即在使用类的时候已经将对象创建完毕
- 优点：实现起来简单；没有多线程安全问题
- 缺点：当类被加载时候，会初始化static实例，静态变量被创建分配内存空间，从这以后，这个static的实例一直占着这块内存，知道类被卸载时，静态变量被摧毁，并释放所占有空间。因此在某些特定条件下辉耗费内存

**懒汉式**

- 特点：延迟加载，即在调用静态方法时实例才被创建
- 优点：实现比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存
- 缺点：在多线程环境中，这种实现方法是完全错误的，线程不安全，根本不能保证单例的唯一性

#### 单例模式优点

由于单例模式只生成一个实例，减少了系统性能开销，当一个对象产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式解决。

**应用场景**

- Windows的Task Manager (任务管理器)就是很典型的单例模式

- Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。

- Application 也是单例的典型应用

- 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只

  能有一个实例去操作，否则内容不好追加。

- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。

### 理解main()方法的语法

由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必须创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保持秩序Java命令时传递给运行数组的类的参数

```java
public class CommandPara {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            System.out.println(args[i]);
        }
    }
}
```

```shell
canvs@CanvsdeiMac-Pro Desktop % java CommandPara "Tom" "Jack" "Canvs"
```

### 类的成员：代码块

如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，可以考虑代码块（或初始化块）

- 一个类中代码块若有修饰符，则只能是static修饰，称为静态代码块(static block)
- 没有使用static修饰的，为非静态代码块

#### 静态代码块

**静态代码块特点**

- 可以有输出语句
- 可以对类的属性、类的声明进行初始化操作
- 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法
- 若有多个代码块，那么按照从上到下的顺序依次执行
- 静态代码块执行要先于非静态代码块
- 静态代码块随着类的加载而加载，且只执行一次

```java
public class Person {
    private static String name;
    private static int age;
    public Person() {
    }
    static {	//静态方法块
        Person.name = "Canvs";
        Person.age = 20;
    }
    public static String getName() {
        return name;
    }
    public static int getAge() {
        return age;
    }
}
```

```java
public class PersonTest {
    public static void main(String[] args) {
        System.out.println("name="+Person.getName()+" age="+Person.getAge()); 
    }
}
```

#### 非静态代码块

- 和构造器一样，也是用于实例变量的初始化操作
- 如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块，减少冗余

**非静态代码块特点**

- 可以有输出语句
- 可以对类的属性、类的声明进行初始化操作
- 除了调用非静态的结构外，还可以调用静态的变量和方法
- 有多个非静态代码块，那么按照从上到下顺序依次执行
- 每次创建对象的时候，都会执行一次。且先于构造器执行

**例子**

- User类
  - 包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化
  - 包含get/set方法，其中registrationTime没有set方法
  - 包含无参构造
  - 包含有参构造(String username, String password)
  - 包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx”

```java
public class User {
    private String username;
    private String password;
    private long registrationTime;
    public User() {
        this.username = registrationTime+"";
        this.password = "123456";
    }

    {
        this.registrationTime = System.currentTimeMillis();
    }
    public User(String username, String password) {
        this();
        this.username = username;
        this.password = password;
    }
    public String getInfo() {
        return "username:" + username + " password:" + password + " registrationTime:" + registrationTime;
    }
    public String getUsername() {
        return username;
    }
    public void setUsernam(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public long getRegistrationTime() {
        return registrationTime;
    }

}
```

```java
public class UserTest {
    public static void main(String[] args) {
        User u1 = new User();
        User u2 = new User("Canvs", "xjp@fuck");
        System.out.println(u1.getInfo());
        System.out.println(u2.getInfo());
    }
}
```

#### 实例变量赋值顺序

![](imgs/oop_static.jpg)

### final关键字

final：最终的，不可更改的

#### final修饰类

表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。如：String类、System类、StringBuffer类

<img src="imgs/nojjkongfu.jpeg" style='float:left;'  />

```java
final class Eunuch{}
```

#### final修饰方法

表示这个方法不能被子类重写

```java
class Father{
	public final void method(){}
}
```

#### final修饰变量

final修饰某个变量（成员变量或局部变量），一旦赋值，它就不能被修改，即常量，常量命名建议使用大写字母

**修饰成员变量**

```java
public final class FinalTest {
    public static int totalNumber=5;
    public final int ID;
    public FinalTest(){
        ID = ++totalNumber;
    }
    public static void main(String[] args) {
        FinalTest ft = new FinalTest();
        System.out.println(ft.ID);
    }
}
```

**修饰局部变量**

```java
public class FinalTest2 {
    public static void main(String[] args) {
        final int MIN_SCORE;
        MIN_SCORE = 0;
        final int MAX_SCORE=100;
    }
}
```

### 抽象类与抽象方法（abstract）

